{"config":{"indexing":"full","lang":["en","de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"atomos | Framework Documentation For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Index"},{"location":"#atomos-framework-documentation","text":"For full documentation visit mkdocs.org .","title":"atomos | Framework Documentation"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"documentation/","text":"Documentation Architecture Framework","title":"Documentation"},{"location":"documentation/#documentation","text":"","title":"Documentation"},{"location":"documentation/#architecture","text":"","title":"Architecture"},{"location":"documentation/#framework","text":"","title":"Framework"},{"location":"tags/","text":"Tags Following is an index list of relevant tags: Architecture Architecture Framework Architecture","title":"Tags"},{"location":"tags/#tags","text":"Following is an index list of relevant tags:","title":"Tags"},{"location":"tags/#architecture","text":"Architecture","title":"Architecture"},{"location":"tags/#framework","text":"Architecture","title":"Framework"},{"location":"architecture/architecture/","tags":["Framework","Architecture"],"text":"Architecture Architecture Components Domain The domain contains models , events , and commands . Domain modeling is the process of abstracting reality into models (entities), events, and commands that are triggered by those events. It is assumed that the domain can model any real-world entity, thus being complete . In an event-driven system , events define the information that can be received ( input messages ) and triggered ( output messages ) by the system. As in reality, events trigger actions or so-called commands . An event can trigger one or a finite number of commands. The triggered commands in turn define the state changes to the domain model of the system. Thus, a command execution is required to change any model state. Message Bus The message bus processes the incoming internal and external events and commands by routing them to relating handlers. Handler mappings define the relationship between the domain entity (command or event) and the implemented handler (function) . The arguments (dependencies, e.g. UOW, adapters, etc.) of a handler function are injected using signature reflection . Unit of Work (UOW) A unit of work (UOW) is a stateful abstraction around data integrity. Each unit of work defines an atomic update to the domain model. The different states (e.g. commit, rollback) enforce data integrity and avoid inconsistency, especially in case of errors. Adapters Adapters define interfaces to communicate with external resources (e.g. third-party service, databases, message broker, (email) notifications/messaging, file system, etc.). Repository A repository is an abstraction around persistent storage (e.g. database system). Each aggregate has its own repository. Message Broker A message broker is an intermediary message-oriented middleware that enables asynchronous communication between clients. The clients can be producers/publishers or consumers/subscribers of messages. The broker is responsible to receive, validate, process (ordering, filtering, queueing), and deliver the messages (events). As the broker acts as a decoupled, isolated middleware, producers and consumers do not necessarily need to know about each other's existence. A broker summons a star network topology , reducing the overall network complexity , supporting scalability , and performance . In the meantime, a broker introduces a highly system-critical component that needs to ensure high resilience in the dimensions of security , performance , scalability , etc. API The API (application programming interface) defines external entrypoints to the system. In other architecture designs it is not uncommon that the API layer directly communicates with the handlers or even the domain and corresponding adapters (like the repository). This design creates a strong coupling between the API layer and the service/data layer. Following the event-driven approach, event messages define the input/output information to and from the system. Therefore, the API layer should only trigger the processing of events. The architecture overview diagram illustrates that the triggered events of the API layer are consumed by the message bus that route the messages to their corresponding handlers. Architecture Diagrams Overview The following graphic provides a simplified overview about the system, divided into application layers: Application Layer Description API Layer APIs act as external entrypoints to the system. As the architecture follows an event-driven approach, event messages define the actions that can be triggered by the API layer. The triggered event messages are processed by the service layer (in particular the message bus), thus enabling a loose coupling between individual API wrappers and the system. This approach enables to easily add, remove, or swap out API endpoints, as the only dependency that needs to be maintained is the connection to the service layer's message bus. Service Layer The service layer is responsible to process triggered events and commands. Events define the triggered actions of the API layer, while commands define the depending state changes of an event. The events and commands are processed by the service layer's message bus, which monitors the execution of event/command messages and enforces data integrity by rolling back erroneous state changes. The data integrity is enforced by the service layer's unit of work (UOW), which defines an abstraction around an atomic update to the system's data layer (e.g. repository adapter). The UOW can commit an atomic update in case of success, or rollback in case of failure. Adapters Layer The adapters layer contains interfaces (\"adapters\") to communicate with external resources outside the system (e.g. repository / database, message broker, (email) notifications, etc.). (Package) Organization The following graphic illustrates the package organization of the framework. ( Please note that all shown packages start with the prefix atomos.<package> , so the package core.domain would be located at atomos.core.domain . ) References Architecture Patterns with Python (H. J.W. Percival & B. Gregory) [web]","title":"Architecture"},{"location":"architecture/architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/architecture/#architecture-components","text":"","title":"Architecture Components"},{"location":"architecture/architecture/#domain","text":"The domain contains models , events , and commands . Domain modeling is the process of abstracting reality into models (entities), events, and commands that are triggered by those events. It is assumed that the domain can model any real-world entity, thus being complete . In an event-driven system , events define the information that can be received ( input messages ) and triggered ( output messages ) by the system. As in reality, events trigger actions or so-called commands . An event can trigger one or a finite number of commands. The triggered commands in turn define the state changes to the domain model of the system. Thus, a command execution is required to change any model state.","title":"Domain"},{"location":"architecture/architecture/#message-bus","text":"The message bus processes the incoming internal and external events and commands by routing them to relating handlers. Handler mappings define the relationship between the domain entity (command or event) and the implemented handler (function) . The arguments (dependencies, e.g. UOW, adapters, etc.) of a handler function are injected using signature reflection .","title":"Message Bus"},{"location":"architecture/architecture/#unit-of-work-uow","text":"A unit of work (UOW) is a stateful abstraction around data integrity. Each unit of work defines an atomic update to the domain model. The different states (e.g. commit, rollback) enforce data integrity and avoid inconsistency, especially in case of errors.","title":"Unit of Work (UOW)"},{"location":"architecture/architecture/#adapters","text":"Adapters define interfaces to communicate with external resources (e.g. third-party service, databases, message broker, (email) notifications/messaging, file system, etc.).","title":"Adapters"},{"location":"architecture/architecture/#repository","text":"A repository is an abstraction around persistent storage (e.g. database system). Each aggregate has its own repository.","title":"Repository"},{"location":"architecture/architecture/#message-broker","text":"A message broker is an intermediary message-oriented middleware that enables asynchronous communication between clients. The clients can be producers/publishers or consumers/subscribers of messages. The broker is responsible to receive, validate, process (ordering, filtering, queueing), and deliver the messages (events). As the broker acts as a decoupled, isolated middleware, producers and consumers do not necessarily need to know about each other's existence. A broker summons a star network topology , reducing the overall network complexity , supporting scalability , and performance . In the meantime, a broker introduces a highly system-critical component that needs to ensure high resilience in the dimensions of security , performance , scalability , etc.","title":"Message Broker"},{"location":"architecture/architecture/#api","text":"The API (application programming interface) defines external entrypoints to the system. In other architecture designs it is not uncommon that the API layer directly communicates with the handlers or even the domain and corresponding adapters (like the repository). This design creates a strong coupling between the API layer and the service/data layer. Following the event-driven approach, event messages define the input/output information to and from the system. Therefore, the API layer should only trigger the processing of events. The architecture overview diagram illustrates that the triggered events of the API layer are consumed by the message bus that route the messages to their corresponding handlers.","title":"API"},{"location":"architecture/architecture/#architecture-diagrams","text":"","title":"Architecture Diagrams"},{"location":"architecture/architecture/#overview","text":"The following graphic provides a simplified overview about the system, divided into application layers: Application Layer Description API Layer APIs act as external entrypoints to the system. As the architecture follows an event-driven approach, event messages define the actions that can be triggered by the API layer. The triggered event messages are processed by the service layer (in particular the message bus), thus enabling a loose coupling between individual API wrappers and the system. This approach enables to easily add, remove, or swap out API endpoints, as the only dependency that needs to be maintained is the connection to the service layer's message bus. Service Layer The service layer is responsible to process triggered events and commands. Events define the triggered actions of the API layer, while commands define the depending state changes of an event. The events and commands are processed by the service layer's message bus, which monitors the execution of event/command messages and enforces data integrity by rolling back erroneous state changes. The data integrity is enforced by the service layer's unit of work (UOW), which defines an abstraction around an atomic update to the system's data layer (e.g. repository adapter). The UOW can commit an atomic update in case of success, or rollback in case of failure. Adapters Layer The adapters layer contains interfaces (\"adapters\") to communicate with external resources outside the system (e.g. repository / database, message broker, (email) notifications, etc.).","title":"Overview"},{"location":"architecture/architecture/#package-organization","text":"The following graphic illustrates the package organization of the framework. ( Please note that all shown packages start with the prefix atomos.<package> , so the package core.domain would be located at atomos.core.domain . )","title":"(Package) Organization"},{"location":"architecture/architecture/#references","text":"Architecture Patterns with Python (H. J.W. Percival & B. Gregory) [web]","title":"References"},{"location":"framework/framework/","text":"Framework Objective In computer programming, a software framework is an abstraction in which software, providing generic functionality, can be selectively changed by additional user-written code, thus providing application-specific software. It provides a standard way to build and deploy applications and is a universal, reusable software environment that provides particular functionality as part of a larger software platform to facilitate the development of software applications, products and solutions. Software frameworks may include support programs, compilers, code libraries, toolsets, and application programming interfaces (APIs) that bring together all the different components to enable development of a project or system. (Wikipedia) The objective of this event-driven framework is to provide a system of high-level abstraction components that act as building blocks to develop performant, secure, resilient, distributed, and scalable microservices. Building Blocks Besides the system architecture , the framework provides a variety of system components that act as the building blocks to create microservices. Domain A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. (Eric Evans) The domain contains models , events , and commands that in conjunction abstract the reality or fictional entities. Domain engineering / modeling refers to the process of abstracting real-world entities to digital domain entities. The framework provides abstract bases for custom models, events, and commands: atomos/core/domain/events/event.py @dataclass class Event: pass @dataclass class UserCreated(event.Event): username: Optional[str] email: Optional[str] roles: Optional[List[role.Role]] = field(default_factory=lambda: []) atomos/core/domain/commands/command.py @dataclass class Command: pass @dataclass class CreateUser(command.Command): username: str password: str email: str roles: Optional[List[role.Role]] = field(default_factory=lambda: []) atomos/core/domain/model/model.py class EventQueue(abc.ABC): events: Optional[List[event.Event]] = [] class Model(EventQueue): id: Optional[str] = str(uuid4()) The Model base inherits the abstract base class EventQueue , which optionally stores a list of events. This allows the service layer's message bus ( atomos/core/service/bus/message_bus.py ) to dynamically monitor newly triggered events that relate to the model. @dataclass class User(model.Model): username: str password: Optional[str] = None email: Optional[str] = None roles: Optional[List[role.Role]] = field(default_factory=lambda: []) id: Optional[uuid.UUID] = uuid.uuid4() def __hash__(self): return hash(self.username) def __eq__(self, other): return isinstance(other, User) and self.id is other.id Adapters Repository Repositories are classes or components that encapsulate the logic required to access data sources. They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer. (Microsoft) Every repository defines a domain aggregate. The events and commands that are received by the service layer's message bus will be handled by a unit of work (UOW), which defines an atomic update to the data persistence layer, in particular the repository. Thus, an abstract UOW depends on an abstract repository. Concrete UOW implementations (like a SQLAlchemy UOW) depend on concrete repository implementations (like a SQLAlchemy repository implementation): The framework provides an abstract base repository class that acts as an initial building block to develop custom repository aggregates: atomos/core/adapters/repository/repository.py class Repository(abc.ABC): collected_entities: Set[model.Model] def __init__(self): self.collected_entities = set() A custom repository aggregate could then be defined as an abstract repository itself, depending on the abstract base repository: class UserRepository(repository.Repository): def __init__(self): super().__init__() async def create_user( self, username: str, password: str, email: Optional[str], ): await self._create_user(username, password, email) self.collected_entities.add(user_model.User(username, password, email)) async def get_user(self, username: Optional[str] = None, email: Optional[str] = None) -> Optional[user_model.User]: result = await self._get_user(username=username, email=email) if result: self.collected_entities.add(result) return result async def query_users(self, **criterion) -> Iterable[user_model.User]: results = await self._query_users(**criterion) if results: self.collected_entities.union(results) return results async def update_user(self, username: Optional[str], email: Optional[str], **update): await self._update_user(username, email, **update) async def delete_user(self, username: Optional[str] = None, email: Optional[str] = None): await self._delete_user(username=username, email=email) @abc.abstractmethod async def _create_user( self, username: str, password: str, email: Optional[str], ): raise NotImplementedError @abc.abstractmethod async def _get_user(self, username: Optional[str], email: Optional[str]) -> Optional[user_model.User]: raise NotImplementedError @abc.abstractmethod async def _query_users(self, **criterion) -> Iterable[user_model.User]: raise NotImplementedError @abc.abstractmethod async def _update_user(self, username: Optional[str], email: Optional[str], **update): raise NotImplementedError @abc.abstractmethod async def _delete_user(self, **criterion): raise NotImplementedError The framework provides an abstract base SQLAlchemy repository that inherits the abstract base repository: atomos/core/adapters/repository/sqlalchemy_repository.py class SQLAlchemyRepository(repository.Repository, abc.ABC): def __init__(self, session: Session = factory.DEFAULT_SESSION_FACTORY()): super().__init__() self.session: Session = session The SQLAlchemy repository base can then be applied to create custom SQLAlchemy repository implementations: class SQLAlchemyUserRepository( sqlalchemy_repository.SQLAlchemyRepository, repository.IdentityRepository ): def __init__(self, session: Session = factory.DEFAULT_SESSION_FACTORY()): super().__init__(session) self.session = session async def _create_user( self, username: str, password: str, email: Optional[str], ): if not await self._get_user(username=username, email=email): self.session.add(user_model.User(username, password, email)) async def _get_user(self, **criterion) -> Optional[user_model.User]: data = { k: v for k, v in criterion.items() if k in ['username', 'email'] and v is not None } if not data: return None return self.session.query(user_model.User).filter_by(**data).first() async def _query_users(self, **criterion) -> Iterable[user_model.User]: return self.session.query(user_model.User).filter_by(**criterion).all() async def _update_user(self, username: Optional[str], email: Optional[str], **update): self.session.query(user_model.User).filter_by(username=username, email=email).update(**update) async def _delete_user(self, **criterion): result = await self._get_user(**criterion) if result: self.session.delete(result) (Event) Messaging | Message Broker Event messaging describes an architectural approach in which the communication between system components happens by exchanging events. An event defines an immutable action that was triggered by a user/client or system component itself. A message broker is an intermediary message-oriented middleware that is responsible to receive, process, and deliver event messages. The messages are triggered by so-called producers/publisher, while the processed messages are delived to corresponding consumers/subscribers. Producers and consumers do not necessarily need to know about each other's existence. A message-oriented middleware (MOM), like a message broker, reduces the overall network complexity by creating a star topology, thus enabling a loose coupling between the producers and consumers. In contrast, a message broker introduces a highly system-critical component that needs to be designed and developed resilient in the dimensions of security, performance, and scalability. A message broker can additionally provide asynchronous communication between producers and consumers of messages by implementing a message queue . Erroneous message processes can be temporarily stored on a dead-letter queue in order to ensure delivery and data consistency. The framework provides an abstract message broker, as well as a concrete Redis publish/subscribe-broker (pub/sub) implementation. atomos/core/adapters/messaging/message_broker.py class MessageBroker(abc.ABC): @abc.abstractmethod async def publish(self, channel: str, event: event.Event): logger.info('publishing: channel=%s, events=%s', channel, event) raise NotImplementedError @abc.abstractmethod async def subscribe(self, channel: str): logger.info('subscribing: channel=%s', channel) raise NotImplementedError @abc.abstractmethod async def process(self, handle: Callable[..., Awaitable]): raise NotImplementedError atomos/core/adapters/messaging/redis_pub_sub_broker.py class RedisPubSubBroker(message_broker.MessageBroker): def __init__(self, host: str = config.REDIS_HOST, port: int = config.REDIS_PORT): self._client = redis.Redis(host=host, port=port) self._pub_sub = self._client.pubsub(ignore_subscribe_messages=True) async def publish(self, channel: str, event: event.Event): self._client.publish(channel, json.dumps(asdict(event))) async def subscribe(self, channel: str): self._pub_sub.subscribe(channel) async def process(self, handle: Callable[..., Awaitable]): for message in self._pub_sub.listen(): await handle(message) Service Layer Unit of Work (UOW) A unit of work (UOW) defines an abstraction around an atomic update to the data layer (in particular the a repository adapter in this architecture). The UOW enforces data integrity and consistency by monitoring the execution of state changes, comitting the updates in case of success, or rolling back in case of failure. The framework provides generic abstractions for the UOW that act as the building blocks to create custom UOW implementations: atomos/core/service/uow/unit_of_work.py T = TypeVar('T', bound=repository.Repository) class UnitOfWork(Generic[T], contextlib.AbstractAsyncContextManager, abc.ABC): repository: T async def __aenter__(self) -> UnitOfWork: return self async def __aexit__(self, *args): await self.rollback() async def commit(self): await self._commit() async def rollback(self): await self._rollback() def collect_new_events(self): for entity in self.repository.collected_entities: while entity.events: yield entity.events.pop(0) @abc.abstractmethod async def _commit(self): raise NotImplementedError @abc.abstractmethod async def _rollback(self): raise NotImplementedError atomos/core/service/uow/sqlalchemy_unit_of_work.py SessionFactory = Callable[..., Session] T = TypeVar('T', bound=sqlalchemy_repository.SQLAlchemyRepository) class SQLAlchemyUnitOfWork(Generic[T], unit_of_work.UnitOfWork[T], abc.ABC): def __init__( self, repository_factory: Type[sqlalchemy_repository.SQLAlchemyRepository], session_factory: SessionFactory = factory.DEFAULT_SESSION_FACTORY, ): self.repository_factory: Type[sqlalchemy_repository.SQLAlchemyRepository] = repository_factory self.session_factory: SessionFactory = session_factory async def __aenter__(self): self.session: Session = self.session_factory() self.repository: T = self.repository_factory(self.session) return await super().__aenter__() async def __aexit__(self, *args): await super().__aexit__(*args) self.session.close() async def _commit(self): self.session.commit() async def _rollback(self): self.session.rollback() The generic design of the UOW bases allows to easily create custom UOW implementations: class SQLAlchemyUserUnitOfWork( sqlalchemy_unit_of_work.SQLAlchemyUnitOfWork[sqlalchemy_repository.SQLAlchemyUserRepository], ): def __init__(self, session_factory: sqlalchemy_unit_of_work.SessionFactory = factory.DEFAULT_SESSION_FACTORY): super().__init__(sqlalchemy_repository.SQLAlchemyUserRepository, session_factory) References Software framework (Wikipedia) Design the infrastructure persistence layer (Microsoft) Domain (software engineering) (Wikipedia)","title":"Framework"},{"location":"framework/framework/#framework","text":"","title":"Framework"},{"location":"framework/framework/#objective","text":"In computer programming, a software framework is an abstraction in which software, providing generic functionality, can be selectively changed by additional user-written code, thus providing application-specific software. It provides a standard way to build and deploy applications and is a universal, reusable software environment that provides particular functionality as part of a larger software platform to facilitate the development of software applications, products and solutions. Software frameworks may include support programs, compilers, code libraries, toolsets, and application programming interfaces (APIs) that bring together all the different components to enable development of a project or system. (Wikipedia) The objective of this event-driven framework is to provide a system of high-level abstraction components that act as building blocks to develop performant, secure, resilient, distributed, and scalable microservices.","title":"Objective"},{"location":"framework/framework/#building-blocks","text":"Besides the system architecture , the framework provides a variety of system components that act as the building blocks to create microservices.","title":"Building Blocks"},{"location":"framework/framework/#domain","text":"A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. (Eric Evans) The domain contains models , events , and commands that in conjunction abstract the reality or fictional entities. Domain engineering / modeling refers to the process of abstracting real-world entities to digital domain entities. The framework provides abstract bases for custom models, events, and commands: atomos/core/domain/events/event.py @dataclass class Event: pass @dataclass class UserCreated(event.Event): username: Optional[str] email: Optional[str] roles: Optional[List[role.Role]] = field(default_factory=lambda: []) atomos/core/domain/commands/command.py @dataclass class Command: pass @dataclass class CreateUser(command.Command): username: str password: str email: str roles: Optional[List[role.Role]] = field(default_factory=lambda: []) atomos/core/domain/model/model.py class EventQueue(abc.ABC): events: Optional[List[event.Event]] = [] class Model(EventQueue): id: Optional[str] = str(uuid4()) The Model base inherits the abstract base class EventQueue , which optionally stores a list of events. This allows the service layer's message bus ( atomos/core/service/bus/message_bus.py ) to dynamically monitor newly triggered events that relate to the model. @dataclass class User(model.Model): username: str password: Optional[str] = None email: Optional[str] = None roles: Optional[List[role.Role]] = field(default_factory=lambda: []) id: Optional[uuid.UUID] = uuid.uuid4() def __hash__(self): return hash(self.username) def __eq__(self, other): return isinstance(other, User) and self.id is other.id","title":"Domain"},{"location":"framework/framework/#adapters","text":"","title":"Adapters"},{"location":"framework/framework/#repository","text":"Repositories are classes or components that encapsulate the logic required to access data sources. They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer. (Microsoft) Every repository defines a domain aggregate. The events and commands that are received by the service layer's message bus will be handled by a unit of work (UOW), which defines an atomic update to the data persistence layer, in particular the repository. Thus, an abstract UOW depends on an abstract repository. Concrete UOW implementations (like a SQLAlchemy UOW) depend on concrete repository implementations (like a SQLAlchemy repository implementation): The framework provides an abstract base repository class that acts as an initial building block to develop custom repository aggregates: atomos/core/adapters/repository/repository.py class Repository(abc.ABC): collected_entities: Set[model.Model] def __init__(self): self.collected_entities = set() A custom repository aggregate could then be defined as an abstract repository itself, depending on the abstract base repository: class UserRepository(repository.Repository): def __init__(self): super().__init__() async def create_user( self, username: str, password: str, email: Optional[str], ): await self._create_user(username, password, email) self.collected_entities.add(user_model.User(username, password, email)) async def get_user(self, username: Optional[str] = None, email: Optional[str] = None) -> Optional[user_model.User]: result = await self._get_user(username=username, email=email) if result: self.collected_entities.add(result) return result async def query_users(self, **criterion) -> Iterable[user_model.User]: results = await self._query_users(**criterion) if results: self.collected_entities.union(results) return results async def update_user(self, username: Optional[str], email: Optional[str], **update): await self._update_user(username, email, **update) async def delete_user(self, username: Optional[str] = None, email: Optional[str] = None): await self._delete_user(username=username, email=email) @abc.abstractmethod async def _create_user( self, username: str, password: str, email: Optional[str], ): raise NotImplementedError @abc.abstractmethod async def _get_user(self, username: Optional[str], email: Optional[str]) -> Optional[user_model.User]: raise NotImplementedError @abc.abstractmethod async def _query_users(self, **criterion) -> Iterable[user_model.User]: raise NotImplementedError @abc.abstractmethod async def _update_user(self, username: Optional[str], email: Optional[str], **update): raise NotImplementedError @abc.abstractmethod async def _delete_user(self, **criterion): raise NotImplementedError The framework provides an abstract base SQLAlchemy repository that inherits the abstract base repository: atomos/core/adapters/repository/sqlalchemy_repository.py class SQLAlchemyRepository(repository.Repository, abc.ABC): def __init__(self, session: Session = factory.DEFAULT_SESSION_FACTORY()): super().__init__() self.session: Session = session The SQLAlchemy repository base can then be applied to create custom SQLAlchemy repository implementations: class SQLAlchemyUserRepository( sqlalchemy_repository.SQLAlchemyRepository, repository.IdentityRepository ): def __init__(self, session: Session = factory.DEFAULT_SESSION_FACTORY()): super().__init__(session) self.session = session async def _create_user( self, username: str, password: str, email: Optional[str], ): if not await self._get_user(username=username, email=email): self.session.add(user_model.User(username, password, email)) async def _get_user(self, **criterion) -> Optional[user_model.User]: data = { k: v for k, v in criterion.items() if k in ['username', 'email'] and v is not None } if not data: return None return self.session.query(user_model.User).filter_by(**data).first() async def _query_users(self, **criterion) -> Iterable[user_model.User]: return self.session.query(user_model.User).filter_by(**criterion).all() async def _update_user(self, username: Optional[str], email: Optional[str], **update): self.session.query(user_model.User).filter_by(username=username, email=email).update(**update) async def _delete_user(self, **criterion): result = await self._get_user(**criterion) if result: self.session.delete(result)","title":"Repository"},{"location":"framework/framework/#event-messaging-message-broker","text":"Event messaging describes an architectural approach in which the communication between system components happens by exchanging events. An event defines an immutable action that was triggered by a user/client or system component itself. A message broker is an intermediary message-oriented middleware that is responsible to receive, process, and deliver event messages. The messages are triggered by so-called producers/publisher, while the processed messages are delived to corresponding consumers/subscribers. Producers and consumers do not necessarily need to know about each other's existence. A message-oriented middleware (MOM), like a message broker, reduces the overall network complexity by creating a star topology, thus enabling a loose coupling between the producers and consumers. In contrast, a message broker introduces a highly system-critical component that needs to be designed and developed resilient in the dimensions of security, performance, and scalability. A message broker can additionally provide asynchronous communication between producers and consumers of messages by implementing a message queue . Erroneous message processes can be temporarily stored on a dead-letter queue in order to ensure delivery and data consistency. The framework provides an abstract message broker, as well as a concrete Redis publish/subscribe-broker (pub/sub) implementation. atomos/core/adapters/messaging/message_broker.py class MessageBroker(abc.ABC): @abc.abstractmethod async def publish(self, channel: str, event: event.Event): logger.info('publishing: channel=%s, events=%s', channel, event) raise NotImplementedError @abc.abstractmethod async def subscribe(self, channel: str): logger.info('subscribing: channel=%s', channel) raise NotImplementedError @abc.abstractmethod async def process(self, handle: Callable[..., Awaitable]): raise NotImplementedError atomos/core/adapters/messaging/redis_pub_sub_broker.py class RedisPubSubBroker(message_broker.MessageBroker): def __init__(self, host: str = config.REDIS_HOST, port: int = config.REDIS_PORT): self._client = redis.Redis(host=host, port=port) self._pub_sub = self._client.pubsub(ignore_subscribe_messages=True) async def publish(self, channel: str, event: event.Event): self._client.publish(channel, json.dumps(asdict(event))) async def subscribe(self, channel: str): self._pub_sub.subscribe(channel) async def process(self, handle: Callable[..., Awaitable]): for message in self._pub_sub.listen(): await handle(message)","title":"(Event) Messaging | Message Broker"},{"location":"framework/framework/#service-layer","text":"","title":"Service Layer"},{"location":"framework/framework/#unit-of-work-uow","text":"A unit of work (UOW) defines an abstraction around an atomic update to the data layer (in particular the a repository adapter in this architecture). The UOW enforces data integrity and consistency by monitoring the execution of state changes, comitting the updates in case of success, or rolling back in case of failure. The framework provides generic abstractions for the UOW that act as the building blocks to create custom UOW implementations: atomos/core/service/uow/unit_of_work.py T = TypeVar('T', bound=repository.Repository) class UnitOfWork(Generic[T], contextlib.AbstractAsyncContextManager, abc.ABC): repository: T async def __aenter__(self) -> UnitOfWork: return self async def __aexit__(self, *args): await self.rollback() async def commit(self): await self._commit() async def rollback(self): await self._rollback() def collect_new_events(self): for entity in self.repository.collected_entities: while entity.events: yield entity.events.pop(0) @abc.abstractmethod async def _commit(self): raise NotImplementedError @abc.abstractmethod async def _rollback(self): raise NotImplementedError atomos/core/service/uow/sqlalchemy_unit_of_work.py SessionFactory = Callable[..., Session] T = TypeVar('T', bound=sqlalchemy_repository.SQLAlchemyRepository) class SQLAlchemyUnitOfWork(Generic[T], unit_of_work.UnitOfWork[T], abc.ABC): def __init__( self, repository_factory: Type[sqlalchemy_repository.SQLAlchemyRepository], session_factory: SessionFactory = factory.DEFAULT_SESSION_FACTORY, ): self.repository_factory: Type[sqlalchemy_repository.SQLAlchemyRepository] = repository_factory self.session_factory: SessionFactory = session_factory async def __aenter__(self): self.session: Session = self.session_factory() self.repository: T = self.repository_factory(self.session) return await super().__aenter__() async def __aexit__(self, *args): await super().__aexit__(*args) self.session.close() async def _commit(self): self.session.commit() async def _rollback(self): self.session.rollback() The generic design of the UOW bases allows to easily create custom UOW implementations: class SQLAlchemyUserUnitOfWork( sqlalchemy_unit_of_work.SQLAlchemyUnitOfWork[sqlalchemy_repository.SQLAlchemyUserRepository], ): def __init__(self, session_factory: sqlalchemy_unit_of_work.SessionFactory = factory.DEFAULT_SESSION_FACTORY): super().__init__(sqlalchemy_repository.SQLAlchemyUserRepository, session_factory)","title":"Unit of Work (UOW)"},{"location":"framework/framework/#references","text":"Software framework (Wikipedia) Design the infrastructure persistence layer (Microsoft) Domain (software engineering) (Wikipedia)","title":"References"},{"location":"tags/","text":"Tags Following is an index list of relevant tags: Architecture Architecture Framework Architecture","title":"Tags"},{"location":"tags/#tags","text":"Following is an index list of relevant tags:","title":"Tags"},{"location":"tags/#architecture","text":"Architecture","title":"Architecture"},{"location":"tags/#framework","text":"Architecture","title":"Framework"}]}